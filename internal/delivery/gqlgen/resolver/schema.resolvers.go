package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.39

import (
	"context"
	"errors"
	"playground/internal/delivery/gqlgen/gen"
	"playground/internal/delivery/gqlgen/helper"
	"playground/internal/pkg/token"
	"playground/internal/wallet"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input gen.NewUser) (*gen.User, error) {
	if usr, err := r.w.CreateUser(ctx, &wallet.CreateUserParams{
		Username: input.Username,
		Password: input.Password,
		FullName: input.Fullname,
		Email:    input.Email,
	}); err != nil {
		return nil, err
	} else {
		return convertUser(usr), nil
	}
}

// LoginUser is the resolver for the loginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, input gen.LoginUser) (*gen.LoginUserResponse, error) {
	md := ctx.Value(helper.MetadataCtxkey).(*helper.Metadata)
	args := &wallet.LoginUserParams{
		Username:  input.Username,
		Password:  input.Password,
		UserAgent: md.UserAgent,
		ClientIP:  md.ClientIP,
	}
	resp, err := r.w.LoginUser(ctx, args)
	if err != nil {
		return nil, err
	}

	return &gen.LoginUserResponse{
		User:                  convertUser(resp.User),
		SessionID:             resp.SessionID.String(),
		AccessToken:           resp.AccessToken,
		RefreshToken:          resp.RefreshToken,
		AccessTokenExpiresAt:  resp.AccessTokenExpiresAt,
		RefreshTokenExpiresAt: resp.RefreshTokenExpiresAt,
	}, nil
}

// CreateAccount is the resolver for the createAccount field.
func (r *mutationResolver) CreateAccount(ctx context.Context, input gen.NewAccount) (*gen.Account, error) {
	authPayload, ok := ctx.Value(helper.AuthCtxkey).(*token.Payload)
	if !ok {
		return nil, errors.New("missing auth payload")
	} else if err := authPayload.Valid(); err != nil {
		return nil, err
	}

	if a, err := r.w.CreateAccount(ctx, &wallet.CreateAccountParams{
		Owner:    authPayload.Username,
		Balance:  0,
		Currency: input.Currency,
	}); err != nil {
		return nil, err
	} else {
		return convertAccount(a), nil
	}
}

// Accounts is the resolver for the accounts field.
func (r *queryResolver) Accounts(ctx context.Context, limit int, offset int) ([]*gen.Account, error) {
	authPayload, ok := ctx.Value(helper.AuthCtxkey).(*token.Payload)
	if !ok {
		return nil, errors.New("missing auth payload")
	} else if err := authPayload.Valid(); err != nil {
		return nil, err
	}

	if as, err := r.w.ListAccounts(ctx, &wallet.ListAccountsParams{
		Owner:  authPayload.Username,
		Limit:  int32(limit),
		Offset: int32(offset),
	}); err != nil {
		return nil, err
	} else {
		var accounts []*gen.Account
		for _, a := range as {
			account := &a
			accounts = append(accounts, convertAccount(account))
		}
		return accounts, nil
	}
}

// Mutation returns gen.MutationResolver implementation.
func (r *Resolver) Mutation() gen.MutationResolver { return &mutationResolver{r} }

// Query returns gen.QueryResolver implementation.
func (r *Resolver) Query() gen.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func convertUser(u *wallet.User) *gen.User {
	return &gen.User{
		Username:        u.Username,
		Fullname:        u.FullName,
		Email:           u.Email,
		CreatedAt:       u.CreatedAt,
		IsEmailVerified: u.IsEmailVerified,
	}
}
func convertAccount(a *wallet.Account) *gen.Account {
	return &gen.Account{
		ID:        int(a.ID),
		Owner:     a.Owner,
		Balance:   int(a.Balance),
		Currency:  a.Currency,
		CreatedAt: a.CreatedAt,
	}
}
